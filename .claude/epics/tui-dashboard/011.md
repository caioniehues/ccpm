---
id: "011"
name: Create file parsers (epic, PRD, task)
status: completed
created: 2025-12-23T19:45:00Z
updated: 2025-12-23T20:15:00Z
depends_on: ["005"]
parallel: true
conflicts_with: []
effort: M
---

# Task: Create File Parsers (Epic, PRD, Task)

## Description

Create Go parsers to read and parse the markdown files from `.claude/epics/` and `.claude/prds/` directories. Parse YAML frontmatter and extract task status from checkboxes.

## Acceptance Criteria

- [ ] Epic parser reads `.claude/epics/{name}/epic.md`
- [ ] Task parser reads `.claude/epics/{name}/*.md` (excluding epic.md)
- [ ] PRD parser reads `.claude/prds/{name}.md`
- [ ] YAML frontmatter extracted correctly
- [ ] Task status parsed from frontmatter `status` field
- [ ] Acceptance criteria checkboxes parsed (- [x] vs - [ ])
- [ ] Progress calculated from completed tasks / total tasks
- [ ] File modification times tracked for activity log

## Files to Create

### internal/tui/parser/epic.go

```go
package parser

import (
    "os"
    "path/filepath"
    "gopkg.in/yaml.v3"
    "strings"
)

type EpicFrontmatter struct {
    Name      string `yaml:"name"`
    Status    string `yaml:"status"`
    Created   string `yaml:"created"`
    Updated   string `yaml:"updated"`
    PRD       string `yaml:"prd"`
    GitHub    string `yaml:"github"`
}

type Epic struct {
    Name        string
    Status      string
    Description string
    Content     string
    PRDName     string
    Branch      string
    CreatedAt   string
    ApprovedAt  string
    Progress    float64
    TaskCount   int
    DoneCount   int
    Tasks       []Task
}

func ParseEpic(epicDir string) (*Epic, error) {
    epicPath := filepath.Join(epicDir, "epic.md")
    
    content, err := os.ReadFile(epicPath)
    if err != nil {
        return nil, err
    }
    
    frontmatter, body := splitFrontmatter(string(content))
    
    var fm EpicFrontmatter
    if err := yaml.Unmarshal([]byte(frontmatter), &fm); err != nil {
        return nil, err
    }
    
    // Parse tasks
    tasks, err := ParseTasksInDir(epicDir)
    if err != nil {
        return nil, err
    }
    
    doneCount := 0
    for _, t := range tasks {
        if t.Status == "completed" {
            doneCount++
        }
    }
    
    progress := 0.0
    if len(tasks) > 0 {
        progress = float64(doneCount) / float64(len(tasks))
    }
    
    return &Epic{
        Name:        fm.Name,
        Status:      fm.Status,
        Description: extractDescription(body),
        Content:     body,
        PRDName:     fm.PRD,
        CreatedAt:   fm.Created,
        Progress:    progress,
        TaskCount:   len(tasks),
        DoneCount:   doneCount,
        Tasks:       tasks,
    }, nil
}

func LoadAllEpics(baseDir string) ([]Epic, error) {
    epicsDir := filepath.Join(baseDir, ".claude", "epics")
    
    entries, err := os.ReadDir(epicsDir)
    if err != nil {
        return nil, err
    }
    
    var epics []Epic
    for _, entry := range entries {
        if entry.IsDir() {
            epic, err := ParseEpic(filepath.Join(epicsDir, entry.Name()))
            if err != nil {
                continue // Skip invalid epics
            }
            epics = append(epics, *epic)
        }
    }
    
    return epics, nil
}

func splitFrontmatter(content string) (string, string) {
    if !strings.HasPrefix(content, "---") {
        return "", content
    }
    
    parts := strings.SplitN(content[3:], "---", 2)
    if len(parts) != 2 {
        return "", content
    }
    
    return strings.TrimSpace(parts[0]), strings.TrimSpace(parts[1])
}

func extractDescription(body string) string {
    lines := strings.Split(body, "\n")
    for _, line := range lines {
        line = strings.TrimSpace(line)
        if line != "" && !strings.HasPrefix(line, "#") {
            return line
        }
    }
    return ""
}
```

### internal/tui/parser/task.go

```go
package parser

type TaskFrontmatter struct {
    ID        string   `yaml:"id"`
    Name      string   `yaml:"name"`
    Status    string   `yaml:"status"`
    Epic      string   `yaml:"epic"`
    DependsOn []string `yaml:"depends_on"`
    Effort    string   `yaml:"effort"`
    Created   string   `yaml:"created"`
    Started   string   `yaml:"started_at"`
    Completed string   `yaml:"completed_at"`
}

type Task struct {
    ID          string
    Name        string
    Status      string
    Epic        string
    Description string
    Progress    float64
    DependsOn   string
    BlockedBy   string
    StartedAt   string
    CompletedAt string
}

func ParseTask(path string) (*Task, error) {
    content, err := os.ReadFile(path)
    if err != nil {
        return nil, err
    }
    
    frontmatter, body := splitFrontmatter(string(content))
    
    var fm TaskFrontmatter
    if err := yaml.Unmarshal([]byte(frontmatter), &fm); err != nil {
        return nil, err
    }
    
    // Calculate progress from checkboxes
    progress := calculateCheckboxProgress(body)
    
    dependsOn := ""
    if len(fm.DependsOn) > 0 {
        dependsOn = strings.Join(fm.DependsOn, ", ")
    }
    
    return &Task{
        ID:          fm.ID,
        Name:        fm.Name,
        Status:      fm.Status,
        Epic:        fm.Epic,
        Description: body,
        Progress:    progress,
        DependsOn:   dependsOn,
        StartedAt:   fm.Started,
        CompletedAt: fm.Completed,
    }, nil
}

func ParseTasksInDir(epicDir string) ([]Task, error) {
    entries, err := os.ReadDir(epicDir)
    if err != nil {
        return nil, err
    }
    
    var tasks []Task
    for _, entry := range entries {
        if entry.IsDir() {
            continue
        }
        name := entry.Name()
        if name == "epic.md" || !strings.HasSuffix(name, ".md") {
            continue
        }
        
        task, err := ParseTask(filepath.Join(epicDir, name))
        if err != nil {
            continue
        }
        tasks = append(tasks, *task)
    }
    
    // Sort by ID
    sort.Slice(tasks, func(i, j int) bool {
        return tasks[i].ID < tasks[j].ID
    })
    
    return tasks, nil
}

func calculateCheckboxProgress(content string) float64 {
    checked := strings.Count(content, "- [x]") + strings.Count(content, "- [X]")
    unchecked := strings.Count(content, "- [ ]")
    total := checked + unchecked
    
    if total == 0 {
        return 0
    }
    return float64(checked) / float64(total)
}
```

### internal/tui/parser/prd.go

```go
package parser

type PRDFrontmatter struct {
    Name       string `yaml:"name"`
    Status     string `yaml:"status"`
    Created    string `yaml:"created"`
    ApprovedAt string `yaml:"approved_at"`
}

type PRD struct {
    Name        string
    Status      string
    Content     string
    CreatedAt   string
    ApprovedAt  string
}

func ParsePRD(path string) (*PRD, error) {
    content, err := os.ReadFile(path)
    if err != nil {
        return nil, err
    }
    
    frontmatter, body := splitFrontmatter(string(content))
    
    var fm PRDFrontmatter
    if err := yaml.Unmarshal([]byte(frontmatter), &fm); err != nil {
        return nil, err
    }
    
    return &PRD{
        Name:       fm.Name,
        Status:     fm.Status,
        Content:    body,
        CreatedAt:  fm.Created,
        ApprovedAt: fm.ApprovedAt,
    }, nil
}

func LoadAllPRDs(baseDir string) ([]PRD, error) {
    prdsDir := filepath.Join(baseDir, ".claude", "prds")
    
    entries, err := os.ReadDir(prdsDir)
    if err != nil {
        return nil, err
    }
    
    var prds []PRD
    for _, entry := range entries {
        if entry.IsDir() || !strings.HasSuffix(entry.Name(), ".md") {
            continue
        }
        
        prd, err := ParsePRD(filepath.Join(prdsDir, entry.Name()))
        if err != nil {
            continue
        }
        prds = append(prds, *prd)
    }
    
    return prds, nil
}
```

## Definition of Done

- All parsers correctly extract frontmatter and content
- Task status and progress calculated accurately
- Checkbox parsing works for acceptance criteria
- No panics on malformed files (graceful error handling)
- Unit tests for parser functions
