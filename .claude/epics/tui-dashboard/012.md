---
id: "012"
name: Implement file watcher with fsnotify
status: completed
created: 2025-12-23T19:45:00Z
updated: 2025-12-23T20:15:00Z
depends_on: ["011"]
parallel: false
conflicts_with: []
effort: M
---

# Task: Implement File Watcher with fsnotify

## Description

Implement real-time file watching using fsnotify to detect changes in `.claude/epics/` and `.claude/prds/` directories. Send messages to the TUI when files change to trigger re-parsing and UI updates.

## Acceptance Criteria

- [ ] Watch `.claude/epics/` directory recursively
- [ ] Watch `.claude/prds/` directory
- [ ] Debounce rapid changes (100ms stabilization)
- [ ] Send FileChangedMsg to TUI on change
- [ ] Handle new file creation
- [ ] Handle file deletion
- [ ] Handle file modification
- [ ] Activity log shows file change events
- [ ] Graceful handling of watcher errors

## Files to Create

### internal/tui/parser/watcher.go

```go
package parser

import (
    "path/filepath"
    "time"
    
    "github.com/fsnotify/fsnotify"
    tea "github.com/charmbracelet/bubbletea"
)

// FileChangedMsg sent when files change
type FileChangedMsg struct {
    Path      string
    Operation string // "create", "write", "remove"
    Time      time.Time
}

// WatcherErrorMsg sent on watcher errors
type WatcherErrorMsg struct {
    Err error
}

// Watcher manages file system watching
type Watcher struct {
    watcher   *fsnotify.Watcher
    baseDir   string
    debounce  time.Duration
    lastEvent map[string]time.Time
}

// NewWatcher creates a new file watcher
func NewWatcher(baseDir string) (*Watcher, error) {
    w, err := fsnotify.NewWatcher()
    if err != nil {
        return nil, err
    }
    
    return &Watcher{
        watcher:   w,
        baseDir:   baseDir,
        debounce:  100 * time.Millisecond,
        lastEvent: make(map[string]time.Time),
    }, nil
}

// Start begins watching and returns a command that sends messages
func (w *Watcher) Start(p *tea.Program) error {
    // Watch epics directory
    epicsDir := filepath.Join(w.baseDir, ".claude", "epics")
    if err := w.watchRecursive(epicsDir); err != nil {
        return err
    }
    
    // Watch prds directory
    prdsDir := filepath.Join(w.baseDir, ".claude", "prds")
    if err := w.watcher.Add(prdsDir); err != nil {
        return err
    }
    
    // Start goroutine to process events
    go w.processEvents(p)
    
    return nil
}

func (w *Watcher) watchRecursive(dir string) error {
    return filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return nil // Skip errors
        }
        if info.IsDir() {
            return w.watcher.Add(path)
        }
        return nil
    })
}

func (w *Watcher) processEvents(p *tea.Program) {
    for {
        select {
        case event, ok := <-w.watcher.Events:
            if !ok {
                return
            }
            
            // Skip non-markdown files
            if !strings.HasSuffix(event.Name, ".md") {
                continue
            }
            
            // Debounce
            if last, exists := w.lastEvent[event.Name]; exists {
                if time.Since(last) < w.debounce {
                    continue
                }
            }
            w.lastEvent[event.Name] = time.Now()
            
            // Determine operation
            op := "write"
            if event.Has(fsnotify.Create) {
                op = "create"
            } else if event.Has(fsnotify.Remove) {
                op = "remove"
            }
            
            // Send message to TUI
            p.Send(FileChangedMsg{
                Path:      event.Name,
                Operation: op,
                Time:      time.Now(),
            })
            
        case err, ok := <-w.watcher.Errors:
            if !ok {
                return
            }
            p.Send(WatcherErrorMsg{Err: err})
        }
    }
}

// Close stops the watcher
func (w *Watcher) Close() error {
    return w.watcher.Close()
}
```

### Update internal/tui/update.go

```go
// Add to Update function
case FileChangedMsg:
    // Add to activity log
    entry := ActivityEntry{
        Time:    msg.Time.Format("15:04"),
        Message: fmt.Sprintf("File %s: %s", msg.Operation, filepath.Base(msg.Path)),
        Type:    "info",
    }
    m.ActivityLog = append([]ActivityEntry{entry}, m.ActivityLog...)
    if len(m.ActivityLog) > 50 {
        m.ActivityLog = m.ActivityLog[:50]
    }
    
    // Reload data
    return m, tea.Batch(loadEpics(), loadPRDs())

case WatcherErrorMsg:
    m.LastError = msg.Err
    return m, nil
```

### Update cmd/ccpm-tui/main.go

```go
func main() {
    // Get working directory
    cwd, _ := os.Getwd()
    
    // Create model
    model := tui.NewModel()
    
    // Create program
    p := tea.NewProgram(model, tea.WithAltScreen())
    
    // Start file watcher
    watcher, err := parser.NewWatcher(cwd)
    if err != nil {
        fmt.Printf("Warning: Could not start file watcher: %v\n", err)
    } else {
        defer watcher.Close()
        go watcher.Start(p)
    }
    
    // Run
    if _, err := p.Run(); err != nil {
        fmt.Printf("Error: %v\n", err)
        os.Exit(1)
    }
}
```

## Testing

```bash
# Terminal 1: Run TUI
./ccpm-tui

# Terminal 2: Modify a file
echo "test" >> .claude/epics/test-epic/epic.md

# TUI should show activity log update and refresh data
```

## Definition of Done

- File watcher starts without errors
- Changes in .claude/epics/ trigger updates
- Changes in .claude/prds/ trigger updates
- Activity log shows file change events
- Debouncing prevents rapid duplicate events
- Watcher gracefully handles errors
